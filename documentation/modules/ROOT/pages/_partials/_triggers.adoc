
WARNING: This chapter build is in progress, expect to change and not working as expected

At the end of this chapter you will be able to :

* What are Tekton Triggers
* How to Trigger a Pipeline or Task based on Events

[#tkn-triggers-overview]
== Overview

Until now we have seen how to create Tasks and Pipelines. But whenever it comes to running the Tasks and Pipelines we always relied on doing it manually. In the Chapter we will be expoloring how to do it using Triggers, e.g. say you push a commit in to the source repository and it triggers a PipelineRun to deploy a new application or a TaskRun to push the image to container registry. Lets rock!

include::partial$tekton-nav-to-folder.adoc[tags="folder-all,triggers"]

[#install-tekton-triggers]
== Install Triggers

NOTE: In OpenShfit, the OpenShift pipelines operator installs Tekton Pipelines and Tekton Triggers in openshift-pipelines namespace. Its not needed install Tekton Triggers.

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl apply -f https://storage.googleapis.com/tekton-releases/triggers/previous/{triggers-version}/release.yaml
----

Wait for the Tekton Trigger controller and webhook to be ready:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
watch kubectl -n tekton-pipelines get pods
----

A successful Tekton run should have the highlighted Tekton Trigger pods running in the `tekton-pipelines`:

[.console-output]
[source,bash,subs="+quotes"]
----
NAME                                           READY   STATUS    RESTARTS   AGE
tekton-pipelines-controller-849ccccd7f-gc6dp   1/1     Running   1          3d3h
tekton-pipelines-webhook-75bc7666c-9crwq       1/1     Running   1          3d3h
#tekton-triggers-controller-697c9b844d-9lz4x    1/1     Running   0          15h#
#tekton-triggers-webhook-6bcb96f965-gqrbh       1/1     Running   0          15h#
----

[#tkn-triggers-prepare]
== Prepare namespace

include::ROOT:partial$namespace-prep.adoc[tags="*"]

[#tkn-triggers-create-pipeline]
=== Create Pipeline

As part of the Trigger exercise we will be runing the greeter-app-deploy pipeline, lets deploy the pipeline to be used later:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl apply -n {chapter-namespace} \
  -f link:{github-repo}/{workspaces-repo}/greeter-app-deploy.yaml[$TUTORIAL_HOME/{workspaces-repo}/greeter-app-deploy.yaml^]
----

Verify the available pipelines:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
tkn pipeline -n {chapter-namespace} ls
----

[.console-output]
[source,bash]
----
NAME                    AGE            LAST RUN   STARTED   DURATION   STATUS
greeter-app-deploy   1 minute ago   ---        ---       ---        ---
----

=== Deploy Gitea

Since we need to trigger a Pipeline with a git push, we will deploy a Git server to the local cluster. This will avoid us the need to expose the service to the public internet and also helps us to test things quickly with our local cluster setup.

https://gitea.io/[Gitea] is super quick and easy to install i.e. self-hosted git service. Lets deploy that into the Kubernetes Cluster.

=== Create Gitea Server

We'll run a script that creates the gitea server for us locally passing in as a parameter to the script a minikube based hostname `GITEA_HOSTNAME` that will allow us to access the instance of gitea from our host machine

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
export GITEA_HOSTNAME="gogs.$(minikube ip).nip.io"
$TUTORIAL_HOME/bin/link:{github-repo}/bin/create-gitea.sh[create-gitea.sh^] $GITEA_HOSTNAME
----

In a separate shell you can follow the installation progress by tailing the logs of the gitea operator that was installed into your minikube cluster.

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
stern gitea -n gitea-operator
----

When the script finishes, your gitea deployment should be completed.  A successful deployment will report:
[.console-output]
[source,bash]
----
Gitea server installed and running
----

If you want, you can confirm this by running this command

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl get pods,svc -lapp=gitea
----

Which should yield output that looks something like the following

[.console-output]
[source,bash]
----
NAME                        READY   STATUS    RESTARTS   AGE
pod/gitea-dc5699668-xnzm9   1/1     Running   0          69m

NAME            TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
service/gitea   NodePort   10.107.208.196   <none>        3000:31850/TCP   69m
----

You can access the gitea service using ingress url:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
open http://$GITEA_HOSTNAME
----

.Gitea Home
image::gitea_home.png[]

[#tkn-create-sa]
== Create ServiceAccount, Roles and Role Bindings

We need to query Kubernetes objects, create Triggers and finally deploy the Knative Service as part of this chapter's exercies. Let's create a Kubernetes Service Account and add the required roles/permissions:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl apply -k link:{github-repo}/{triggers-repo}/rbac[+$TUTORIAL_HOME+/{triggers-repo}/rbac]
----

[.console-output]
[source,bash]
----
serviceaccount/pipeline created
role.rbac.authorization.k8s.io/app-deployer-role created
role.rbac.authorization.k8s.io/tekton-triggers-admin created
role.rbac.authorization.k8s.io/tekton-triggers-createwebhook created
rolebinding.rbac.authorization.k8s.io/app-deployer-binding created
rolebinding.rbac.authorization.k8s.io/tekton-triggers-admin-binding created
rolebinding.rbac.authorization.k8s.io/tekton-triggers-createwebhook-binding created
----

NOTE: In OpenShift you might not need the *pipeline* SA, as the OpenShift Pipelines creates it by default

[#tkn-triggers-init-repo]
== Initialize Source Repository

To run the exercises of this chapter we need the following setup in Git(gitea):

- A Git user, for the demo we will create user called *gitea* with password *gitea*
- A Git Repository named `tekton-greeter`, we will use https://github.com/redhat-scholars/tekton-tutorial-greeter

We will run the following Task to perform the necessary intializations listed above:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl create -n {chapter-namespace} \
  -f link:{github-repo}/{triggers-repo}/gitea-init-taskrun.yaml[+$TUTORIAL_HOME+/{triggers-repo}/gitea-init-taskrun.yaml^]
----

[.console-output]
[source,bash]
----
taskrun.tekton.dev/init-gitea-qkf84 created
----

include::ROOT:partial$logs-view.adoc[tags='tr']

A successfull initializations should show an output like:

[.console-output]
[source,bash]
----
[create-gitea-admin] Created Gitea admin user gitea:gitea

[init-gitea] Created git repo tekton-tutorial-greeter
[init-gitea] Repository Clone url http://gitea.192.168.64.7.nip.io/gitea/tekton-tutorial-greeter.git
----

You should now be able to open the *Repository Clone url* from the output above and view the repository content.

[#tkn-triggers-template]
== Trigger Template

TriggerTemplate is responsible to create the Tekton Resources when it receives the Event from the EventListener.

[#tkn-triggers-create-template]
=== Create Trigger Template

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl create -n {chapter-namespace} \
  -f link:{github-repo}/{triggers-repo}/greeter-trigger-template.yaml[greeter-trigger-template.yaml^]
----

[.console-output]
[source,bash]
----
triggertemplate.triggers.tekton.dev/tekton-greeter-trigger-template created
----

List the available TriggerTemplates:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
tkn tt -n {chapter-namespace} ls
----

It should be only one now:

[.console-output]
[source,bash]
----
NAME                                 AGE
tekton-greeter-trigger-template   1 minute ago
----

[#tkn-triggers-bindings]
== Trigger Bindings

TriggerBinding is responsible to bind the Event payload with Template Parameters. In this case it will bind the gogs event playload to TriggerTemplate parameters, inputs, outputs and workspaces.

Let us see a sample webhook payload that Git events from Gogs might look like:

.Gogs Payload sample
[source,json,subs="+quotes"]
----
include::ROOT:example$gogs-payload.json[]
----

We can use any attribute/data from the JSON payload and bind them as the value in TriggerBindings. For this chapter exercise we are interested in two attributes namely:

- *after*: the commit hash after our push is merged into the master
- *repository.clone_url*: The Git Repo clone url

The HTTP Body and Headers of the eventt payload are available as `body` and `header` JSONPath variables. We can retrieve the values using JSONPath expressions. Check the https://github.com/tektoncd/triggers/blob/master/docs/triggerbindings.md#event-variable-interpolation[Event Variable Interpolation] for more details.

To retreieve the `after` and `repository.clone_url` we will the JSONPath expressions `$(body.after)` and `$(body.repoistory.clone_url)` respectively. 

[#tkn-triggers-create-bindings]
=== Create Trigger Bindings

.link:{github-repo}/{triggers-repo}/gogs-triggerbindings.yaml[gogs-triggerbindings.yaml^]
[source,yaml,subs="+quotes"]
----
include::ROOT:example$gogs-triggerbindings.yaml[]
----

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl create -n {chapter-namespace} -f gogs-triggerbindings.yaml
----

[.console-output]
[source,bash]
----
triggerbinding.triggers.tekton.dev/gogs-triggerbinding created
----

List the available TriggerBindings:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
tkn tb -n {chapter-namespace} ls
----

It should show an output like:

[.console-output]
[source,bash]
----
NAME                  AGE
gogs-triggerbinding   7 seconds ago
----

[#tkn-triggers-eventlistener]
== Event Listener

Event Listener is primary interace for external sources to send events, that will trigger the creation of Tekton resources defined as part of the TriggerTemplate.

[#tkn-triggers-create-eventlistener]
=== Create Event Listener

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl apply -n {chapter-namespace} -f link:{github-repo}/{triggers-repo}/gogs-eventlistener.yaml[gogs-eventlistener.yaml]
----

[.console-output]
[source,bash]
----
eventlistener.triggers.tekton.dev/gogs-webhook created
----

List the available EventListeners:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
tkn el -n {chapter-namespace} ls
----

It should show an output like:

[.console-output]
[source,bash]
----
NAME           AGE
gogs-webhook   4 seconds ago
----

Each EventListener will have a service named `el-<EventListener Name>` exposed automatically for sources to send events to Triggers.

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl get svc -n {chapter-namespace} -leventlistener=gogs-webhook
----

[.console-output]
[source,bash,subs="+quotes"]
----
NAME              TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
#el-gogs-webhook   ClusterIP   10.97.199.207    <none>        8080/TCP         51s#
----

=== Create Event Listener Ingress

If you need the EventListner service to be available outside of the cluster thereby you can use them as part of the webhook, the service `el-gogs-webhook` needs to be exposed via Ingress:

[tabs]
====
Minikube::
+
--
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
export EL_WEBHOOK_URL="$(kubectl get svc -n {chapter-namespace} el-gogs-webhook -o yaml \
  | yq r - 'metadata.name').$(minikube ip).nip.io"
export EL_WEBHOOK_LISTENER_PORT="$(kubectl get svc -n {chapter-namespace} el-gogs-webhook -o yaml \
  | yq r - 'spec.ports.(name==http-listener).port')"
----

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
yq w link:{github-repo}/{triggers-repo}/eventlistener-ingress.yaml[eventlistener-ingress.yaml] \
  spec.virtualhost.fqdn $EL_WEBHOOK_URL \
  | yq w - 'spec.routes[0].services[0].name' el-gogs-webhook \
  | yq w - 'spec.routes[0].services[0].port' $EL_WEBHOOK_LISTENER_PORT \
  | kubectl apply -n {chapter-namespace} -f  -
----

[.console-output]
[source,bash]
----
httpproxy.projectcontour.io/el-gogs-webhook-ingress 
----

Lets verify if the ingress has been configured correctly:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl get httpproxy -n {chapter-namespace} el-gogs-webhook-ingress -o yaml
----

The command should the following output (trimmed for brevity):

[.console-output]
[source,bash,subs="+quotes"]
----
apiVersion: projectcontour.io/v1
kind: HTTPProxy
metadata:
  name: el-gogs-webhook-ingress
  namespace: triggers-demo
spec:
  routes:
  - services:
    - name: #el-gogs-webhook#
      port: #8080#
  virtualhost:
    fqdn: #el-gogs-webhook.192.168.64.5.nip.io#
----
--
OpenShift::
+
--
[.console-input]
[source,bash,subs="macros+,+attributes"]
----
oc expose svc -n {chapter-namespace} el-gogs-webhook --targetPort=http-listener
----
--
====

[#tkn-triggers-configure-webhook]
== Configure Webhook

For the GitHub Triggers to work, we need to have the https://gogs.io/docs/features/webhook[Webhook] configured for the Git Repository `tekton-greeter` to point to the `el-gogs-webhook-ingress`:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl create -n {chapter-namespace} \
  -f link:{github-repo}/{triggers-repo}/gogs-webhook-taskrun.yaml[gogs-webhook-taskrun.yaml^]
----

[.console-output]
[source,bash]
----
taskrun.tekton.dev/webhook-gogs-lwkjt created
----

include::ROOT:partial$logs-view.adoc[tags='tr']

A successfull initializations should show an output like:

[.console-output]
[source,bash]
----
[webhook-gogs] Configured webhook: http://el-gogs-webhook.192.168.64.5.nip.io
----

As you note now the `tekton-greeter` Git repository in Gogs is configured with the webhook to send Git events to EventListener.

image::gogs_webhook_settings.png[]

[#tekton-triggers-in-action]
== Triggers in Action

=== Terminal 1 

As we expect the triggers to start a Pipeline, lets open a new terminal and watch the running Pipelines:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
watch tkn pr -n {chapter-namespace} ls
----

You kbd:[Ctrl+c] the watch once you see it running and monitor the logs.

=== Terminal 2

Open a new terminal and watch the logs the event listener to see the incoming events:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
stern -n {chapter-namespace} gogs-webhook
----

Once the event playload is received from the gogs, you should see output(trimmed for brevity) as shown below:

[.console-output]
[source,bash]
----
...
el-gogs-webhook-88bc89db-ld6jz event-listener {"level":"info","logger":"eventlistener","caller":"resources/create.go:93","msg":"Generating resource: kind: &APIResource{Name:pipelineruns,Namespaced:true,Kind:PipelineRun,Verbs:[delete deletecollection get list patch create update watch],ShortNames:[pr prs],SingularName:pipelinerun,Categories:[tekton tekton-pipelines],Group:tekton.dev,Version:v1beta1,StorageVersionHash:4xDTCrDXyFg=,}, name: greeter-app-","knative.dev/controller":"eventlistener"}
el-gogs-webhook-88bc89db-ld6jz event-listener {"level":"info","logger":"eventlistener","caller":"resources/create.go:101","msg":"For event ID \"rrgcn\" creating resource tekton.dev/v1beta1, Resource=pipelineruns","knative.dev/controller":"eventlistener"}
...
----

=== Clone and Edit the source

Using your favorite IDE clone the repo `tekton-greeter` from Gogs using the <<tkn-triggers-init-repo,clone url>>. 

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
git clone <your gogs tekton-greeter clone url>
----

Open the `tekton-tutorial-greeter` in your IDE and edit the Java file:

[tabs]
====
Quarkus::
+
--
- `src/main/java/com/redhat/developers/GreetingResource.java` to update the "Meeow!! from Tekton 😺🚀" to "😺 Tekton Rocks!" 

- `src/test/java/com/redhat/developers/GreetingResourceTest.java` to match "😺 Tekton Rocks!".
--
SpringBoot::
+
--
- `src/main/java/com/redhat/developer/demos/GreetingController.java` to update the "Meeow!! from Tekton 😺🚀" to "😺 Tekton Rocks!" 

- `src/test/java/com/redhat/developer/demos/GreetingControllerTest.java` to match "😺 Tekton Rocks!".
--
====

Commit and push to see the 😺 Pipeline `greeter-app-deploy` running 🚀.

NOTE: Use the username `gogs` and password `gogs` when prompted during Git push to repository.

include::ROOT:partial$logs-view.adoc[tags='pr']

Once the Pipeline succeeds, verify the Knative Service `greeter`:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
http --body (kn service describe greeter -o url)/hello
----

The command should shown output like:

[.console-output]
[source,bash]
----
😺 Tekton Rocks!
----

Expriment with updating the sources to your taste and see the pipeline triggers.

[#tekton-triggers-ptp]
== Points to Ponder

To use Tekton Triggers we need:

- A Kubernetes Service Account with required premissions assigned
- A TriggerTemplate which defines what Tekton Resources to create for a events
- A TriggerBinding which allows to extract the data from the event payload and bind them to Tekton Parameters of Task/Pipeline
- A EventListener that will listen for the  events and trigger the executuion of Tekton Resources as part of the Trigger Template

[#tkn-triggers-cleanup]
== Cleanup

If you no longer going to use the {chapter-namespace}, you can do:

[.console-input]
[source,bash,subs="+macros,attributes+"]
----
kubectl delete ns {chapter-namespace}
----
